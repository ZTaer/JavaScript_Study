<pre>
# 目录:
    0. 资源: 前端算法与数据结构面试：底层逻辑解读与大厂真题训练
    1. 
</pre>

<pre>
# 资源: 前端算法与数据结构面试：底层逻辑解读与大厂真题训练
# 预览: https://juejin.cn/book/6844733800300150797

# 1( 完成笔记 )
    a) 面试算法攻略介绍
# 2( 等待笔记 )
    a) 数组介绍
    b) 数据结构掌握要求:
        0. 数组
        1. 栈
        2. 队列
        3. 链表
        4. 树( 着重点是二叉树 )
    c) 生成数组技巧
        0. new Array(7): 可以创建长度为7的数组
        1. (new Array(7)).fill(1): 可以创建长度为7,每个值为1的数组
            a) (new Array(7)).fill(1) --> [1,1,1,1,1,1]
        2. 注意: 初始化二位数组, 不能使用fill, 因为fill生成的数组内容，指向同一个内存地址
            0. 初始化数组用for循环即可
    d) 矩阵: 二维数组即可称矩阵
        0. 二维数组: 
            arr = [
                [0,1],
                [0,1],
                [0,1],
            ]
        1. 多维数组访问: for循环嵌套
    e) 遍历数组方法:
        0. for ( 推荐 )
        1. forEach
        2. map
    f) 数组方法:
        0. concat
        1. some
        2. slice
        3. join
        4. sort
        5. pop
        6. push
# 3( 等待笔记 )
    a) 介绍: 栈,队列,链表 
    b) 栈: 先进后出
        0. 数组模拟: 数组仅能使用push, pop
        1. 类似卖冰糕
    c) 队列: 先进先出
        0. 数组模拟 :数组仅能使用push, shift
        1. 类似排队干饭
    d) 链表: 
        0. 数组模拟: [ 1, 2, .... ]
        1. 内存模拟:
            {
                // 存储数据
                val: 1
                // 指针域，指向下一个节点
                next: {
                    val: 2
                    next: ... // 依次嵌套
                }
            }
        2. 原因: 数据存储在内存中，并非排列存储，而是打散存储的，因此需要指针指定下个数据位置
        3. 注意: 访问链表中的任何一个元素，我们都得从起点结点开始, 所以要定一个"空节点head"
        4. 操控链表:
            a) 常考点: 任意两结点间插入一个新结点
            b) 链表插入: 创建节点，设置节点指针执向
            c) 链表删除: 其实本质上改变指针指向即可
                0. 例: [1,3,2] 如果删除3, 则1的指针指向3的指针即可, 则变为[1,2]
            d) JS数组: 底层解析
                0. [1,2,3]: 连续内存: 确实是连续的存储
                1. [null,1,{a:1}]: 非连续内存: 哈希映射分配内存空间，是由对象链表来实现的
                2. 不同的数组数据结构JS在内存中实现方式不一样
            e) 链表的优/缺点
                0. 高效的增删操作: ( 优点 ) 
                    a) 添加和删除操作的复杂度是固定的
                    b) 就是添加和删除元素都不需要挪动多余的元素。
                1. 麻烦的访问操作: ( 缺点 )
                    a) 当我们试图读取某一个特定的链表结点时，必须遍历整个链表来查找它
            f) 数组优/缺点
                0. 增删操作不如链表: ( 缺点 )
                    a) 需要考虑元素挪动
                1. 高效访问操作: ( 优点 )
                    a) 直接索引读取
    e) 结论：链表的插入/删除效率较高，而访问效率较低；数组的访问效率较高，而插入效率较低。
        0. 注意: 数据结构选型的依据来单独考察
# 4( 等待笔记 )
    a) 理解二叉树树的结构
    b) 其实二叉树，也是规范的套娃
    c) 数据结构
        0. 根节点{ val: "", left: {}, right: {} }
        1. 有2度二叉树
            {
                val: "1",
                left: {
                    val: "1-1",
                    left: {
                        ...套娃
                    },
                    right: {
                        ...套娃
                    }
                },
                right: {
                    val: "1-2",
                    left: {
                        ...套娃
                    },
                    right: {
                        ...套娃
                    }   
                }
            }
        2. 描述二叉树单位: 如上方, 高度为2，阶乘为2
            a) 高度: 从最后叶子节点 --至--> 根节点
            b) 阶乘: 从根节点 --至--> 最后叶子节点
# 5( 等待笔记 )
    a) 二叉树遍历
    b) 二叉树遍历方式
        0. 递归:
            a) 先序遍历
            b) 中序遍历
            c) 后序遍历
        1. 迭代:
            a) 层次遍历
    c) 每一个二叉树节点结构: 
        0. 根节点, 左子树, 右子树
        1. 保证: 左子树优先右子树, 遍历顺序
            a) 根节点, 左子树, 右子树 ( 先序遍历 )
            b) 左子树, 根节点, 右子树 ( 中序遍历 )
            c) 左子树, 右子树, 根节点 ( 后序遍历 )
# 6( 等待笔记 )
    a) 理解时间复杂度,空间复杂度
    b) 时间复杂度:
        0. 计算结果: 保留最高次幂
        1. 计算技巧:
            a) 判断逻辑: n+1
            b) for嵌套: n * n
            c) 递增: logn
            d) 常数转为1
        2. 时间复杂度: 从小到大的顺序排列
            a) O(1), O(logn), O(n), O(nlogn), O(n^2), O(n^3), O(2^n)
    c) 空间复杂度:
        0. 占用内存大小
        1. 计算技巧:
            a) 递增: n
            b) 指数递增for嵌套: n^2
            c) 常数转为1
        2. 空间复杂度: 从小到大的顺序排列
            a) O(1), O(n), O(n^2)
# 7( 等待笔记 )
    a) 数组的应用
    b) 数组题目特点:
        0. 总体难度适中
        1. 高难度: 数组题目要想往难了出，基本都要结合排序、二分和动态规划这些相对复杂的算法思想才行
    c) 两数求和问题:
        0. 通用解题技巧:
            a) 空间换时间: 目的避免二层for循环
            b) 求和转为求差: 几乎所有的求和问题,都可以转化为求差问题,降低难度
        1. 针对性解题技巧:
            a) Map记录遍历的值，验证求差结果是否正确
    d) 合并两个有序数组:
        0. 通用解题技巧:
            a) 双指针: 避免二层for嵌套，节省时间复杂度
                0. 注意: 双指针通常使用在有序数据
                1. 快慢指针: 每次循环计算,2个指针增加大小不一
                2. 对撞指针: 循环开头位置,一在前，一在尾
# 8( 等待笔记 )
    a) 字符串相关的“基本算法技能” 
    b) 反转字符串
    c) 判断一个字符串是否是回文字符串
        0. 回文字符串: 就是正着读和倒着读都一样的字符串
            a) 判断方法1: 利用反转字符串方法, 反转结果 === 反转前, 则为回文字符串
            b) 判断方法2: 对称性, 前后迭代比对接口相等 ( 重要特性 - 常用 )
    d) 真题: 回文字符串衍生问题
        0. 真题描述：给定一个非空字符串s, 最多删除一个字符, 判断是否能成为回文字符串。



</pre>